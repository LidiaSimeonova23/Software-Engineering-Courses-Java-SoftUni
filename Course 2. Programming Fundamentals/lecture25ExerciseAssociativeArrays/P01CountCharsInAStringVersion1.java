package lecture25ExerciseAssociativeArrays;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

public class P01CountCharsInAStringVersion1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //В тази задача трябва да принтираме по колко пъти се среща всеки символ, с изключение на space (' '), в даден текст.

        //1. прочитаме данните от конзолата
        String text = scanner.nextLine().replaceAll("\\s+", "");       //прочитаме цял ред от конзолата като текст и с метода .replaceAll премахваме интервалите
        //"text text text".replaceAll -> "texttexttext"

        //2. създаваме си асоц. масив (ще ни трябва за стъпка 3.) - от изходните данни виждаме, че редът на прибавяне на записи към асоц. масив се запазва (същият е като реда, по който са прочетени и прибавени)
        //накрая трябва да принтираме символ -> брой срещания  - това е точно като ключ -> стойност (тоест, ще имаме асоциативен масив, тоест map)
        //създаваме си го от вида LinkedHashMap, защото при принтирането си записите трябва да са в реда, в който са били добавени към асоц. масив
        Map<Character, Integer> symbolsMap = new LinkedHashMap<>();

        //3. итерираме (с for или с foreach цикъл) по всеки символ от прочетения текст и го прибавяме като ключ на запис на асоц. масив (а стойността на записа е колко пъти се среща този символ в прочетения текст)
        //ПРЕДИ ДА ПРИБАВИМ ЗАПИС, ПЪРВО ПРОВЕРЯВАМЕ ДАЛИ В АСОЦ. МАСИВ ВЕЧЕ ИМА ЗАПИС С ТАКЪВ КЛЮЧ
        //чрез метод String.toCharArray() превръщаме даден текст (String) в масив от символи (char-ове)
        char[] symbolsArray = text.toCharArray();    //"Desi".toCharArray()   -> ['D', 'e', 's', 'i']
        for (char symbol : symbolsArray) {           //в този вариант на решението за итерирането по символите от прочетения текст ползваме foreach цикъл

            //ако текущият символ е интервал, няма да броим колко пъти се среща (няма да го прибавяме към асоц. масив като ключ)
            //ако при четенето на входните данни не бяхме премахнали интервалите, можехме да направим следното:    //вариант 5 на решението е нещо подобно (също и вариант 6 и вариант 7)
            /*if (symbol == ' ') {     //ако символът съвпада с интервал
                continue;    //пропускаме останалия код от цикъла и преминаваме към следващия символ (тоест, прекъсваме текущата итерация на цикъла и преминаваме към следващата итерация)
            }*/

            if (!symbolsMap.containsKey(symbol)) {       //на всяка итерация на цикъла правим проверка: ако асоциативният масив symbolsMap не съдържа текущия ключ (който ключ в случая е текущият символ)
                symbolsMap.put(symbol, 1);            //към асоциативния масив symbolsMap прибавяме запис с текущия ключ, като съответната му стойност (тоест, колко пъти се среща този символ в прочетения текст) става 1
            } else {      //в противен случай (тоест, ако асоциативният масив symbolsMap вече съдържа запис с такъв ключ (който ключ в случая е текущият символ))
                int numberOfOccurrencesOfCurrentSymbol = symbolsMap.get(symbol);   //създаваме си променлива за домоментната стойност на записа (тоест, тази стойност е брой срещания на текущия символ в прочетения текст) - достъпваме я чрез ключа на записа
                symbolsMap.put(symbol, numberOfOccurrencesOfCurrentSymbol + 1);     //привидно изглежда, че се опитваме към асоц. масив да прибавим ключ, който вече съществува, но всъщност не можем (защото ключът е уникален и в един асоц. масив не може да има записи с еднакви ключове), можем единствено да променяме (презапишем) стойността на записа
            }
        }

        //4. принтираме записите на асоц. масив -> в това решение на задачата принтирането е чрез метод forEach и ламбда израз
        //трябва да принтираме    символ (от прочетения текст) -> брой срещания на символа в прочетения текст
        //entry (запис): key (symbol) -> value (numberOfOccurrencesOfCurrentSymbol)
        symbolsMap.entrySet().forEach(entry -> System.out.println(entry.getKey() + " -> " + entry.getValue()));
        //symbolsMap.entrySet().forEach(entry -> System.out.printf("%c -> %d%n", entry.getKey(), entry.getValue()));
    }
}

package lecture24AssociativeArrays;

import java.util.*;

public class P02WordSynonymsVersion1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = Integer.parseInt(scanner.nextLine());      //от първия ред на конзолата прочитаме цяло число n - то покъзва колко 2 * n реда ще четем (n ще е броят на итерациите)

        //създаваме си асоциативен масив (той ще е от вид LinkedHashMap, защото искаме да се запази редът, в който са добавени записите), който ще пълним със записи (item-и) - ще ги взимаме от конзолата и ще ги добавяме към асоц. масив
        //ключът ще е само 1 елемент от клас String, стойността ще представлява лист (тоест, няколко елемента, а не само един) от клас String
        //целта е, ако вече има такъв ключ
        LinkedHashMap<String, ArrayList<String>> wordsMap = new LinkedHashMap<>();
                             //с ArrayList<String>  указваме, че стойността ще е лист от елементи (тоест, стойността на асоц. масив ще се състои от няколко елемента), но все още не сме създали този лист
        for (int i = 0; i < n; i++) {            //for (int i = 1; i <= n; i++)       //създаваме си for цикъл за n на брой итерации (за да четем входните данни с ключове и стойности)
            String word = scanner.nextLine();         //на всяка итерация на цикъла четем дума (от тип String ще е) - тя ще е ключът на записа (item-a)
            String synonym = scanner.nextLine();       //на всяка итерация на цикъла четем синоним (от тип String ще е) - той ще е стойността на записа (item-a)

            if (!wordsMap.containsKey(word)) {            //ако асоциативният масив не съдържа в себе си ключа (който ключ е прочетената от конзолата дума) ->
                wordsMap.put(word, new ArrayList<>());      //към асоциативния масив да се добави ключът (който ключ е прочетената от конзолата дума) и да се създаде лист за стойността
                //с new ArrayList<>() създаваме нов обект в паметта  - лист, защото до момента нямаме създаден такъв
            }
            //дори и ключът да се съдържа, пак искаме стойността да се добави (но не да презапише старата стойност, а да се добави към нея и стойността всъщност да е лист от стойности
            //List<String> valueList = wordsMap.get(word);    //достъпваме стойността на записа/item-a (която в случая е лист от стрингове) чрез ключа (който ключ е прочетената от конзолата дума) на записа/item-a
            wordsMap.get(word).add(synonym);       //сега вече взимаме само стойността на записа/item-a (която стойност е прочетеният от конзолата синоним) и я добавяме като стойност на асоц. масив - към листа от стойносттите
            //wordsMap.get(word)  ни връща домоментната стойност, а стойността -  new ArrayList<>())   - я определихме като лист      - а от урока за листове знаем, че в листа добавяме елементи (на последно място в листа) чрез метода .add(element)       //тоест, чрез .add(synonym) добавяме елемент в листа, което в случая е добавяне на стойност за асоц. масив
        }

        //създаваме си foreach цикъл, за да итерираме по асоциативния масив и да принтираме неговите записи/item-и (тоест, неговите key - value)
        for (Map.Entry<String, ArrayList<String>> entry : wordsMap.entrySet()) {
            System.out.printf("%s - %s%n", entry.getKey(), String.join(", ", entry.getValue()));      //ключът и стойността на всеки запис да се принтира на отделен ред
                                                           //стойността на всеки запис/item е лист от стрингове, затова я принтираме по начина, по който се принтира String лист
        }

    }
}

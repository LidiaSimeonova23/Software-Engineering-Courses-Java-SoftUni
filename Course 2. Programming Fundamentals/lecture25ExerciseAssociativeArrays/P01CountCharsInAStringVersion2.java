package lecture25ExerciseAssociativeArrays;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

public class P01CountCharsInAStringVersion2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //В тази задача трябва да принтираме по колко пъти се среща всеки символ, с изключение на space (' '), в даден текст.

        //1. прочитаме данните от конзолата
        //от първия ред на конзолата четем масив от символи (char променливи)
        String text = scanner.nextLine();         //четем цял ред като текст     ->  "text text text"
        char[] symbolsArray = text.toCharArray();       //превръщаме прочетения текст в масив от символи   ->  ['t', 'e', 'x', 't', ' ','t', 'e', 'x', 't', ' ', 't', 'e', 'x', 't']
        //предишните два реда код могат да се напишат и само на 1 ред:    char[] symbolsArray = scanner.nextLine().toCharArray();


        //2. създаваме си асоц. масив (ще ни трябва за стъпка 3.) - от изходните данни виждаме, че редът на прибавяне на записи към асоц. масив се запазва (същият е като реда, по който са прочетени и прибавени)
        //накрая трябва да принтираме символ -> брой срещания  - това е точно като ключ -> стойност (тоест, ще имаме асоциативен масив, тоест map)
        //създаваме си го от вида LinkedHashMap, защото при принтирането си записите трябва да са в реда, в който са били добавени към асоц. масив
        Map<Character, Integer> symbolsMap = new LinkedHashMap<>();
        //ключът (в случая ключът ще е даден символ) ще е от тип char, а стойността (в случая стойността ще е колко пъти се среща даденият символ в текста) ще е от тип int

        //3. итерираме (с for или с foreach цикъл) по всеки символ от масива от символи и прибавяме този символ като ключ на запис на асоц. масив (а стойността на записа е колко пъти се среща този символ в масива от символи)
        //ПРЕДИ ДА ПРИБАВИМ ЗАПИС, ПЪРВО ПРОВЕРЯВАМЕ ДАЛИ В АСОЦ. МАСИВ ВЕЧЕ ИМА ЗАПИС С ТАКЪВ КЛЮЧ
        //тоест, обхождаме елементите на масива от символи и ги добавяме (включително и интервала ->  ' ') като ключове на записи на асоциативния масив - в случая ще ползваме метода .putIfAbsent(key, value)  (тоест, записът да се добави към map-а, ако липсва такъв ключ)
        for (char symbol : symbolsArray) {
            symbolsMap.putIfAbsent(symbol, 0);      //на всяка итерация на цикъла към асоц. масив добавяме (АКО ЛИПСВА ТАКЪВ КЛЮЧ В АСОЦ. МАСИВ) запис с ключ - текущия символ  и със стойност на записа - брой срещания на символа в масива от символи - в началото определяме стойността като 0 (тя после ще се трупа)
                       //а ако в асоц. масив вече има такъв ключ, предишният ред с код - symbolsMap.putIfAbsent(symbol, 0);  - ще ни върне false и няма да се изпълни
            int value = symbolsMap.get(symbol);       //създаваме си променлива за домоментната стойност на записа (тоест, тази стойност е брой срещания на текущия символ в масива от символи) - достъпваме я чрез ключа на записа
            symbolsMap.put(symbol, value + 1);       //привидно изглежда, че се опитваме към асоц. масив да прибавим ключ, който вече съществува, но всъщност не можем (защото ключът е уникален и в един асоц. масив не може да има записи с еднакви ключове), можем единствено да променяме (презапишем) стойността на записа
        }


        //4. принтираме записите на асоц. масив (всички с изключение на записа, който съдържа като ключ символа интервал) -> в това решение на задачата принтирането е чрез  foreach цикъл
        //трябва да принтираме    символ (от прочетения текст) -> брой срещания на символа в прочетения текст
        //entry (запис): key (symbol) -> value (numberOfOccurrencesOfCurrentSymbol)
        for (Map.Entry<Character, Integer> entry : symbolsMap.entrySet()) {      //итерираме по всеки запис от асоц. масив
            //проверяваме: ако ключът на записа е различен от символа интервал, записът да се принтира (съответно, ако ключът на записа е символът интервал, записът няма да се принтира)
            if (entry.getKey() != 32) {      //if (entry.getKey() != ' ')     //32 е ASCII кодът, тоест целочислената стойност на символа интервал   //чрез entry.getKey()  взимаме ключа на текущия запис
                System.out.printf("%c -> %d%n", entry.getKey(), entry.getValue());     //на всяка итерация на цикъла да се принтира текущият запис, а именно ключ -> стойност
                //System.out.println(entry.getKey() + " -> " + entry.getValue());
            }
        }

    }
}

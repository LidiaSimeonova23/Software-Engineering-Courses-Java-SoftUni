package lecture9ExerciseDataTypesAndVariables;

import java.util.Scanner;

public class PMoreExercises06BalancedBrackets {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //parentheses е същото като brackets (скоби)

        //ЗА РЕШЕНИЕТО НА ТАЗИ ЗАДАЧА СА ПОЛЗВАТ МАСИВИ - УЧАТ СЕ В ЛЕКЦИЯ 11
        //по принцип най-подходящото решение на задачата е да се ползват стекове (ще ги учим в Java Advanced курса)

        int n = Integer.parseInt(scanner.nextLine());       //от първия ред на конзолата четем цяло число n (брой редове с входни данни) в интервала [1…20]  (вместо int можем да ползваме byte за тип данни)

        //n на брой пъти ще четем текущия ред с входни данни -> знаем колко пъти ще се повтори действието -> for цикъл

        //всичките входни данни са текстове -> можем да ги обединим в една структура от данни - масив от текстове ->
        //създаваме масив от n на брой елемента
        String[] inputLinesArray = new String[n];    //създаваме си String масив от n на брой елемента (в началото всички елементи в масива са с дефолтна стойност null)

        //присвояваме стойности на елементите от масива:
        //ТРЯБВА ДА ОБХОДИМ ВСИЧКИ ЕЛЕМЕНТИ ОТ МАСИВА - ОТ ПЪРВИЯ (НА ИНДЕКС 0) ДО ПОСЛЕДНИЯ (НА ИНДЕКС ДЪЛЖИНАТА НА МАСИВА - 1 ВКЛЮЧ.)
        for (int index = 0; index <= n - 1; index++) {          //for (int index = 0; index < n; index++)
            //по-подробно можем да напишем така:
            //String currentInputLine = scanner.nextLine();      //на всяка итерация на цикъла четем текущия ред с входни данни
            //inputLinesArray[index] = currentInputLine;      //на текущия елемент от масива присвояваме като стойност текущо прочетения ред с входни данни
            inputLinesArray[index] = scanner.nextLine();   //на всяка итерация на цикъла на текущия елемент от масива присвояваме като стойност текущо прочетения текст от конзолата
        }
        //И СЛЕД ВСИЧКИ ИТЕРАЦИИ НА ЦИКЪЛА ВСИЧКИТЕ ЕЛЕМЕНТИ НА МАСИВА ИМАТ КОНКРЕТНИ СТОЙНОСТИ (вече не са null)

        //в тази задача след всяка отваряща скоба трябва да има затваряща скоба, за да са балансирани скобите
        //освен това знаем, че винаги трябва да почнем с отваряща скоба, за да имаме шанс за балансирани скоби (няма как да почнем със затваряща скоба)

        //с for цикъл обхождаме поотделно всеки елемент (който е текст) от масива от текстове:
        boolean isBalanced = false;       //създаваме си допълнителна булева променлива, която да ни държи истината - задаваме, че по подразбиране скобите не са балансирани ("са балансирани" е лъжа)
        for (int index = 0; index < inputLinesArray.length; index++) {          //for (int index = 0; index <= inputLinesArray.length - 1; index++)
            if (inputLinesArray[index].equals("(")) {      //ако текущият елемент (текст) от масива съвпада с отваряща скоба
                isBalanced = false;     //потвърждаваме, че скобите не са балансирани

                //за текущата отваряща скоба трябва да проверим дали след нея следва затваряща скоба
                //с вложен цикъл обхождаме следващите елементи (които са текстове) от масива (тези след текущия елемент/текст)
                for (int nextIndex = index + 1; nextIndex < inputLinesArray.length; nextIndex++) {     //for (int nextIndex = index + 1; nextIndex <= inputLinesArray.length - 1; nextIndex++)
                    if (inputLinesArray[nextIndex].equals(")")) {     //ако следващият елемент (текст) от масива съвпада със затваряща скоба
                        isBalanced = true;         //скобите са балансирани  ("са балансирани" става истина)
                        inputLinesArray[index] = "openingBracket";     //на текущия елемент от масива му присвояваме като стойност "openingBracket"
                        inputLinesArray[nextIndex] = "closingBracket";      //на следващия елемент от масива му присвояваме като стойност "closingBracket"
                        break;      //прекъсваме вътрешния for цикъл (тъй като за текущата отваряща скоба сме намерили съответна затваряща скоба, спираме търсенето по-нататък)
                    }
                }
            }
        }


        if (isBalanced) {          //ако скобите са балансирани (ако "са балансирани" е истина), да се принтира, че са балансирани
            System.out.println("BALANCED");
        } else {     //в противен случай (ако "са балансирани" не е истина) да се принтира, че не са балансирани
            System.out.println("UNBALANCED");
        }

    }
}

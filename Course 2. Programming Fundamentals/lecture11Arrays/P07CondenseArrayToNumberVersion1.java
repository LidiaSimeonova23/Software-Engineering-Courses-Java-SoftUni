package lecture11Arrays;

import java.util.Arrays;
import java.util.Scanner;

public class P07CondenseArrayToNumberVersion1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //В ТОВА РЕШЕНИЕ НА ЗАДАЧАТА СЪЗДАВАМЕ ДВА ДОПЪЛНИТЕЛНИ МАСИВА (ТОВА РЕШЕНИЕ Е ПО-ТРУДНО ЗА ДОСЕЩАНЕ В СРАВНЕНИЕ С ВЕРСИЯ 2 и ВЕРСИЯ 3) /чрез допълнителните два масива успяваме да сведем прочетения от конзолата масив до само 1 елемент/

        //първо трябва да прочетем от конзолата масив от цели числа (ще извършваме аритметични операции с елементите на масива, затова елементите трябва да са числа, а не текстове)
        int[] numbersArray = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();

        //по условие ни е казано, че броят на елементити в масива постепенно ще намалява с 1 елемент, докато се сведе до само 1 елемент
        //знаем, че дължината на масив не се променя -> обаче ->
        //ако в някоя задача се изисква да променим дължина на масив, можем да създадем нов масив (а понякога нови масиви), да му присвоим стойности, след което новия масив да присвоим като стойност на стария масив
        int[] condensedArray = new int[numbersArray.length - 1];    //създаваме нов (допълнителен) целочислен масив с име condensedArray, чиято дължина ще е с един елемент по-малка от дължината на прочетения от конзолата масив numbersArray   (не сме посочили конкретни стойности на елементите в масива condensedArray, затова те имат дефолтна стойност 0 - тя е дефолтна за данни от тип int)

        //трябва да събираме всички два сеседни елемента на прочетения от конзолата масив numbersArray -> трябва да обходим масива (по принцип това винаги може да стане с for цикъл, понякога може и с foreach цикъл)
        //на всяка итерация на for цикъла трябва да взимаме не само един, а два елемента (текущия елемент и следващия елемент) - ще използваме for цикъл (а не foreach), защото само чрез for цикъл можем да достъпваме елементите чрез уникалния им индекс
        for (int index = 0; index < numbersArray.length; index++) {     //for (int index = 0; index <= numbersArray.length - 1; index++)
            if (numbersArray.length == 1) {    //най-логично и лесно е първо да проверим - ако броят на елементите в масива numbersArray е точно 1, ще прекъснем цикъла (тъй като няма следващ елемент, с който да го събираме)
                break;    //прекъсваме for цикъла (и отиваме да изпълним кода извън for цикъла)
            }

            //ако дължината на масива numbersArray не е 1, значи е повече от 1 и ще имаме два варианта:
            if (index == numbersArray.length - 1) {    //ако текущият индекс е последният индекс в масива numbersArray (ако елементът, който се намира на текущия index, е последният елемент от масива numbersArray)
                int[] condensedSecondArray = new int[condensedArray.length - 1];     //създаваме още един нов (допълнителен) целочислен масив с име condensedSecondArray, чиято дължина ще е с един елемент по-малка от дължината на condensedArray   (не сме посочили конкретни стойности на елементите в масива condensedSecondArray, затова те имат дефолтна стойност 0 - тя е дефолтна за данни от тип int)
                index = -1;   //на текущия индекс присвояваме стойност -1
                numbersArray = condensedArray;      //на прочетения от конзолата масив numbersArray присвояваме като стойност първия създаден сгъстен масив (а именно condensedArray) - така реално намаляваме дължината на масив numbersArray (като същевременно с това променяме стойностите на елементите му)
                condensedArray = condensedSecondArray;      //на първия създаден сгъстен масив (а именно condensedArray) присвояваме като стойност втория създаден сгъстен масив (а именно condensedSecondArray)  - така реално намаляваме дължината на масив condensedArray (като същевременно стова променяме стойностите на елементите му)
            } else {   //в противен случай (тоест, ако текущият индекс не е последният индекс в масива numbersArray)
                condensedArray[index] = numbersArray[index] + numbersArray[index + 1];   //на текущия елемент от масив condensedArray присвояваме като стойност сбора/сумата от текущия и следващия елемент от масив numbersArray
            }
        }

        //само веднъж (извън for цикъла) принтираме единствения елемент на обновения вид на масив numbersArray, който получихме (това реално е последната намерена сума от последните два съседни елемента)
        System.out.println(numbersArray[0]);
        //System.out.printf("%d", numbersArray[0]);
    }
}

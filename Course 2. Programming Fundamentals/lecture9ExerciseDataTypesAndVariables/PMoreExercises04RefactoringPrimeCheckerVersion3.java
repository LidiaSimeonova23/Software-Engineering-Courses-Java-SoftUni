package lecture9ExerciseDataTypesAndVariables;

import java.util.Scanner;

public class PMoreExercises04RefactoringPrimeCheckerVersion3 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //ТОВА РЕШЕНИЕ (ВЕРСИЯ 3) НА ЗАДАЧАТА Е ВЯРНО, НО ВЕРСИЯ 1 И ВЕРСИЯ 2 СА ПО-ПОДХОДЯЩИ  (В ТОВА РЕШЕНИЕ СЕ ПРАВЯТ ДОПЪЛНИТЕЛНИ/ИЗЛИШНИ ИТЕРАЦИИ ЗА БРОЕНЕ НА ДЕЛИТЕЛИТЕ НА ТЕКУЩОТО ЧИСЛО)
        //ТОВА РЕШЕНИЕ Е ПОДХОДЯЩО ДА СЕ ПОЛЗВА, КОГАТО ТРЯБВА ДА ЗНАЕМ БРОЯ НА ДЕЛИТЕЛИТЕ (АКО ЧИСЛОТО Е СЛОЖНО); АКО ЧИСЛОТО Е ПРОСТО, ДЕЛИТЕЛИТЕ МУ СА ТОЧНО ДВА (1 И САМОТО ЧИСЛО)

        int number = Integer.parseInt(scanner.nextLine());       //от първия ред на конзолата четем едно цяло число

        //едно число е просто, ако се дели само на 1 и на себе си  (тоест, броят на делителите му е точно 2)  /0 и 1 не са прости числа/
        //по условие трябва да проверяваме дали са прости или не числата, които са в диапазона от 2 вкл. до number вкл.   ->  ще имаме два вложени цикъла:
        //във външния цикъл взимаме текущото число (в диапазона от 2 до number, прочетено от конзолата);
        //а във вътрешния цикъл ще проверяваме това текущо число на колко числа се дели, като почнем от 1 и стигнем до самото текущо число
        for (int currentNumber = 2; currentNumber <= number; currentNumber++) {        //за да ми е по-удобно, си кръстих променливата currentNumber вместо i

            int divisorsCounter = 0;        //създаваме си променлива за брояч на делителите на текущото число
            boolean isPrime = true;      //създаваме си допълнителна булева променлива, която да ни държи истината - приемаме по подразбиране, че числото е просто (тоест, има точно 2 делителя) - затова му задаваме начална стойност true

            for (int currentDivisor = 1; currentDivisor <= currentNumber; currentDivisor++) {     //за да ми е по-удобно, си кръстих променливата currentDivisor вместо j
                if (currentNumber % currentDivisor == 0) {        //ако текущото число модулно се дели на текущия делител без остатък (с остатък 0), значи делението е точно
                    divisorsCounter++;     //divisorsCounter += 1;    //divisorsCounter = divisorsCounter + 1;     //броят на делителите на текущото число се увеличава с единица
                }
            }

            if (divisorsCounter > 2) {      // if (divisorsCounter >= 3)   //ако броят на делителите е повече от 2 (тоест, числото се дели не само на 1 и на себе си, но и на друго/други числа), числото не е просто (а е сложно)
                isPrime = false;     //твърдението "числото е просто"  става лъжа (тоест, казваме, че числото не е просто)
            }

            System.out.printf("%d -> %b%n", currentNumber, isPrime);    //на всяка итерация на външния for цикъл принтираме текущото число и срещу него дали е просто (true) или не (false)
        }

    }
}

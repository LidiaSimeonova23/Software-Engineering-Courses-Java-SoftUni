package lecture11Arrays;

import java.util.Arrays;
import java.util.Scanner;

public class P06EqualArraysVersion1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);


        //от конзолата трябва да прочетем два масива - може да се наложи да извършваме аритметични операции с елементите -> ще четем масиви от цели числа:
        int[] firstArray = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();      //от първия ред на конзолата четем първия целочислен масив - с функционално програмиране
        int[] secondArray = Arrays.stream(scanner.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();     //от втория ред на конзолата четем втория целочислен масив - с функционално програмиране

        //по принцип има две условия, за да се твърди, че два масива са еднакви: 1. дължините им трябва да са равни и 2. елементите на съответните индекси трябва да са еднакви/равни

        //в тази задача няма нужда да се проверява дали дължините на двата масива са еднакви - спрямо входните данни от всички тестове се вижда, че дължините на двата масива са еднакви
        //следователно, трябва да проверяваме само дали елементите на съответните индекси съвпадат
        //винаги при сравнения най-лесно се решава задачата, ако се открие поне една разлика (извод - различни са), или ако след всички проверки не е открита нито една разлика (извод - еднакви са)

        //ще итерираме по всеки един елемент от първия масив; ще сравним текущия елемент от първия масив със съответния текущ елемент от втория масив;
        //ако някъде открием разлика - веднага правим извод, че масивите са различни и прекъсваме програмата; ако след всички извършени итерации не е открита нито една двойка различни елементи, масивите са еднакви
        //тъй като достъпваме текущия елемент от масива чрез неговия уникален индекс, в тази задача не можем да обхождаме елементите на масива с foreach цикъл, защото с него не можем да достъпваме текущия елмент (при foreach няма индекси)
        int sumOfElementsInArray = 0;    //създаваме допълнителна променлива за сумата от елементите на първия масив (с начално стойност 0)
        int differenceInIndex = 0;    //създаваме допълнителна променлива differenceInIndex (разликата между елементите е в индекс) - с начална стойност 0
        boolean areIdentical = true;    //създаваме допълнителна променлива areIdentical, която да ни държи истината (по подразбиране приемаме, че двата масива са еднакви)

        for (int index = 0; index < firstArray.length; index++) {    //начало на цикъла е първият елемент в масива (на индекс 0), край на цикъла е последният елемент (на индекс дължината на масива - 1 включително)
            int currentElementOfFirstArray = firstArray[index];    //създаваме променлива currentElementOfFirstArray за текущия елемент от първия масив и й  присвояваме като стойност елемента от масива на текущия индекс
            int currentElementOfSecondArray = secondArray[index];   //създаваме променлива currentElementOfSecondArray за текущия елемент от втория масив и й  присвояваме като стойност елемента от масива на текущия индекс

            if (currentElementOfFirstArray == currentElementOfSecondArray) {   //ако текущият елемент от първия масив е равен на текущия елемент от втория масив
                sumOfElementsInArray += currentElementOfFirstArray;   //sumOfElementsInArray = sumOfElementsInArray + currentElementOfFirstArray;     //прибавяме текущия елемент от първия масив към домоментната сума от елементите на първия масив
                //вместо currentElementOfFirstArray можехме да ползваме currentElementOfSecondArray (двата са еднаква)
            } else {     //else if (currentElementOfFirstArray != currentElementOfSecondArray)    //в противен случай (ако текущият елемент от първия масив не е равен на текущия елемент от втория масив)
                areIdentical = false;     //развяваме флага, че двата масива не са еднакви ("са еднакви" става лъжа)
                differenceInIndex = index;   //на променливата differenceInIndex присвояваме като стойност текущия index
                break;   //прекъсваме цикъла   //ако не сложим break (тоест, ако не прекъснем цикъла), ще продължим да сравняваме текущите елементи (и да правим излишни итерации) и накрая няма да се принтира първият индекс, на който е открита разлика между текущите елементи, а ще се принтира последният индекс, на който е открита разлика разлика между текущите елементи
            }

        }


        if (areIdentical) {      //ако двата масива са еднакви
            System.out.printf("Arrays are identical. Sum: %d", sumOfElementsInArray);     //принтираме, че са еднакви; принтираме и намерената сума от елементите на един от двата масива
        } else {     //else if (!areIdentical)     // в противен случай (ако двата масива не са еднакви)
            System.out.printf("Arrays are not identical. Found difference at %d index.", differenceInIndex);    //принтираме, че не са еднакви, както и индекса, на който е открита разлика
        }

    }
}

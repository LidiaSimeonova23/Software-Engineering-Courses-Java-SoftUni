package lecture25ExerciseAssociativeArrays;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

public class P01CountCharsInAStringVersion6 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        //В тази задача трябва да принтираме по колко пъти се среща всеки символ, с изключение на space (' '), в даден текст.

        //1. прочитаме данните от конзолата
        String text = scanner.nextLine();       //прочитаме цял ред от конзолата като текст
        //"text text text"

        //2. създаваме си асоц. масив (ще ни трябва за стъпка 3.) - от изходните данни виждаме, че редът на прибавяне на записи към асоц. масив се запазва (същият е като реда, по който са прочетени и прибавени)
        //накрая трябва да принтираме символ -> брой срещания  - това е точно като ключ -> стойност (тоест, ще имаме асоциативен масив, тоест map)
        //създаваме си го от вида LinkedHashMap, защото при принтирането си записите трябва да са в реда, в който са били добавени към асоц. масив
        Map<Character, Integer> symbolsMap = new LinkedHashMap<>();

        //3. итерираме (с for или с foreach цикъл) по всеки символ от прочетения текст и го прибавяме като ключ на запис на асоц. масив (а стойността на записа е колко пъти се среща този символ в прочетения текст)
        //ПРЕДИ ДА ПРИБАВИМ ЗАПИС, ПЪРВО ПРОВЕРЯВАМЕ ДАЛИ В АСОЦ. МАСИВ ВЕЧЕ ИМА ЗАПИС С ТАКЪВ КЛЮЧ
        for (int index = 0; index <= text.length() - 1; index++) {     //в този вариант на решението за итерирането по символите от прочетения текст ползваме for цикъл
            char currentSymbol = text.charAt(index);     //създаваме си променлива за текущия символ от текста (достъпваме символа чрез уникалния му индекс)

            if (currentSymbol == ' ') {     //ако символът е интервал
                continue;    //пропускаме останалия код от цикъла и преминаваме към следващия символ (тоест, прекъсваме текущата итерация на цикъла и преминаваме към следващата итерация)
            } else {       //в противен случай (ако символът не е интервал)
                if (!symbolsMap.containsKey(currentSymbol)) {       //на всяка итерация на цикъла правим проверка: ако асоциативният масив symbolsMap не съдържа текущия ключ (който ключ в случая е текущият символ)
                    symbolsMap.put(currentSymbol, 1);            //към асоциативния масив symbolsMap прибавяме запис с текущия ключ, като съответната му стойност (тоест, колко пъти се среща този символ в прочетения текст) става 1
                } else {      //в противен случай (тоест, ако асоциативният масив symbolsMap вече съдържа запис с такъв ключ (който ключ в случая е текущият символ))
                    int numberOfOccurrencesOfCurrentSymbol = symbolsMap.get(currentSymbol);   //създаваме си променлива за домоментната стойност на записа (тоест, тази стойност е брой срещания на текущия символ в прочетения текст) - достъпваме я чрез ключа на записа
                    symbolsMap.put(currentSymbol, numberOfOccurrencesOfCurrentSymbol + 1);     //привидно изглежда, че се опитваме към асоц. масив да прибавим ключ, който вече съществува, но всъщност не можем (защото ключът е уникален и в един асоц. масив не може да има записи с еднакви ключове), можем единствено да променяме (презапишем) стойността на записа
                }
            }

        }


        //4. принтираме записите на асоц. масив -> в това решение на задачата принтирането е чрез метод forEach и ламбда израз
        //трябва да принтираме    символ (от прочетения текст) -> брой срещания на символа в прочетения текст
        //entry (запис): key (symbol) -> value (numberOfOccurrencesOfCurrentSymbol)
        symbolsMap.entrySet().forEach(entry -> System.out.println(entry.getKey() + " -> " + entry.getValue()));
        //symbolsMap.entrySet().forEach(entry -> System.out.printf("%c -> %d%n", entry.getKey(), entry.getValue()));
    }
}
